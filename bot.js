// https://github.com/octokit/core.js#readme
const { Octokit } = require('@octokit/core');
const octokit = new Octokit({auth: process.env.GITHUB});
const constants = require('./constants.json');
const markdown = require('./audits/markdown.js');
const psi = require('./audits/psi.js');
const dom = require('./audits/dom.js');

const url = (number, path) => {
  const s1 = path.substring(0, path.lastIndexOf('/'));
  const s2 = s1.substring(s1.lastIndexOf('/') + 1);
  return `https://deploy-preview-${number}--web-dev-staging.netlify.app/${s2}/`;
};

const createReviewComment = data => {
  let comment = 'This is an auto-generated pull request review. ';
  comment += 'I use a Markdown linter, PageSpeed Insights, and Puppeteer to detect common problems.\n\n';
  // TODO(kaycebasques): Check descriptions.json for audit description and bail if not found.
  comment += `Comment ID: ${constants.comments.review}`;
  return {comment, data};
};

const createStagingUrlsComment = data => {
  let comment = 'Hello! For your convenience, here are direct links (on our staging site) to the content you created or updated:\n';
  for (const path in data.files) {
    const file = data.files[path];
    comment += `* ${file.url}\n`;
  }
  comment += `\nThis message was auto-generated by my GitHub bot. Comment ID: ${constants.comments.staging}`; 
  return comment;
};

// The keys of this object match the names of the relevant GitHub webhook event
// that we're responding to.
const actions = {
  // On this one we can kick off the source code auditing but
  // not the staged site auditing, because Netlify isn't ready yet.
  // That suggests the Markdown auditing should be in a different function?
  // audit() should be renamed to scrape()?
  opened: async data => {
    audit(data.number);
  },
  created: data => {
    audit(data.issue.number);
  },
  edited: data => {
    audit(data.issue.number)
  },
  synchronize: data => {
    audit(data.number);
  }
};

const audit = async number => {
  // Store data about the pull request.
  let data = {
    files: {},
    number
  };  
  // Get the files that are affected by the pull request.
  const files = await octokit.request({
    method: 'GET',
    url: `/repos/googlechrome/web.dev/pulls/${number}/files`
  });
  // Check for new content, modified content, or images.
  const newContent =
      files.data.filter(file => file.status === constants.files.added &&
          file.filename.toLowerCase().endsWith('.md'));
  const modifiedContent =
      files.data.filter(file => file.status === constants.files.modified &&
          file.filename.toLowerCase().endsWith('.md'));
  const images =
      files.data.filter(file => file.filename.toLowerCase().endsWith('.png') ||
          file.filename.toLowerCase().endsWith('.jpg'));
  // Bail if the PR doesn't touch any content files.
  // TODO(kaycebasques): What about images?
  if (newContent.length === 0 && modifiedContent.length === 0) return;
  // Store data about the new or modified content.
  if (newContent.length > 0) {
    newContent.forEach(file => {
      data.files[file.filename] = {
        status: constants.files.added,
        url: url(number, file.filename),
        raw: file.raw_url,
        audits: {}
      };
    });
  }
  if (modifiedContent.length > 0) {
    modifiedContent.forEach(file => {
      data.files[file.filename] = {
        status: constants.files.modified,
        url: url(number, file.filename),
        raw: file.raw_url,
        audits: {}
      };
    });
  }

  // Audit the files.
  for (const path in data.files) {
    const file = data.files[path];
    file.audits.markdown = await markdown.audit(file.raw, path);
    // file.audits.psi = await psi.audit(file.url);
    // file.audits.dom = await dom.audit(file.url);
  }

  // Get the comments on the pull request.
  const comments = await octokit.request({
    accept: 'application/vnd.github.v3+json',
    method: 'GET',
    url: `/repos/googlechrome/web.dev/issues/${number}/comments`
  });
  // Check for the auto-generated staging URLs comment.
  const stagingUrlsComment = comments.data.filter(comment => {
    return comment.body.includes(constants.comments.staging);
  });
  // Create the auto-generated staging URLs comment if it doesn't exist.
  if (stagingUrlsComment.length === 0) {
    await octokit.request({
      accept: 'application/vnd.github.v3+json',
      method: 'POST',
      url: `/repos/googlechrome/web.dev/issues/${data.number}/comments`,
      body: createStagingUrlsComment(data)
    });
  }
  // Otherwise just update it.
  if (stagingUrlsComment.length === 1) {
    await octokit.request({
      accept: 'application/vnd.github.v3+json',
      method: 'PATCH',
      url: `/repos/googlechrome/web.dev/issues/comments/${stagingUrlsComment[0].id}`,
      body: createStagingUrlsComment(data)
    });
  }

  // const reviewType = pr.data.user.login === 'kaycebasques' ? 'COMMENT' : 'REQUEST_CHANGES';
  // Cannot request changes on your own pull request
  // await octokit.request({
  //   accept: 'application/vnd.github.v3+json',
  //   method: 'POST',
  //   url: `/repos/googlechrome/web.dev/pulls/${number}/reviews`,
  //   body: createReviewComment(data),
  //   event: reviewType
  // });

  return createReviewComment(data);
};

module.exports = {
  actions,
  audit
}