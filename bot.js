// The bot that acts on my behalf
// Need to create a single comment, detect that comment, update

const axios = require('axios');
// https://github.com/octokit/core.js#readme
const { Octokit } = require('@octokit/core');
const octokit = new Octokit({auth: process.env.GITHUB});
const markdown = require('./markdown.js');
const psi = require('./psi.js');
// const report = require('./report.js');
const constants = require('./constants.json');
// const descriptions = require('./descriptions.json');
const dom = require('./dom.js');

const url = (number, path) => {
  const s1 = path.substring(0, path.lastIndexOf('/'));
  const s2 = s1.substring(s1.lastIndexOf('/') + 1);
  return `https://deploy-preview-${number}--web-dev-staging.netlify.app/${s2}/`;
};

const createReviewComment = data => {
  let comment = 'This is an auto-generated pull request review. ';
  comment += 'I use a Markdown linter, PageSpeed Insights, and Puppeteer to detect common problems.\n\n';
  // TODO(kaycebasques): Check descriptions.json for audit description and bail if not found.
  comment += `Comment ID: ${constants.comments.review}`;
  return {comment, data};
};

const createStagingUrlsComment = data => {
  let comment = 'Hello! For your convenience, here are direct links (on our staging site) to the content you created or updated:\n';
  for (const path in data.files) {
    const file = data.files[path];
    comment += `* ${file.url}\n`;
  }
  comment += `\nThis message was auto-generated by my GitHub bot. Comment ID: ${constants.comments.staging}`; 
  return comment;
};

const actions = {
  // On this one we can kick off the source code auditing but
  // not the staged site auditing, because Netlify isn't ready yet.
  // That suggests the Markdown auditing should be in a different function?
  // audit() should be renamed to scrape()?
  opened: async data => {
    audit(data.number);
    // const url =
    //     `https://api.github.com/repos/googlechrome/web.dev/pulls/${data.number}/files`;
    // const pr = await axios.get(url);
    // audit(null);
  },
  // https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/webhook-events-and-payloads#issue_comment
  created: data => {
    audit(data.issue.number);
  },
  edited: data => {
    audit(data.issue.number)
  },
  synchronize: data => {
    audit(data.number);
  }
}

// <!-- markdownlint-disable-next-line MD001 MD005 -->
const audit = async number => {
  number = 4363; // DEBUG
  let data = {
    files: {},
    number
  };
  // const data = {
  //   files: {
  //     added: [],
  //     modified: []
  //   },
  //   status: {
  //     staging: false
  //   },
  //   staging: null,
  //   number
  // };
  
  const beta = [
    'kaycebasques'
  ];
  // Get general PR data
  const pr = await octokit.request({
    accept: 'application/vnd.github.v3+json',
    method: 'GET',
    url: `/repos/googlechrome/web.dev/pulls/${number}`
  });
  // Bail if the author isn't part of our beta program.
  if (!beta.includes(pr.data.user.login)) return;

  
  

  // Get the files that are affected by the pull request.
  const files = await octokit.request({
    method: 'GET',
    url: `/repos/googlechrome/web.dev/pulls/${number}/files`
  });
  // Check for new content, modified content, or images.
  const newContent =
      files.data.filter(file => file.status === 'added' &&
          file.filename.toLowerCase().endsWith('.md'));
  const modifiedContent =
      files.data.filter(file => file.status === 'modified' &&
          file.filename.toLowerCase().endsWith('.md'));
  const images =
      files.data.filter(file => file.filename.toLowerCase().endsWith('.png') ||
          file.filename.toLowerCase().endsWith('.jpg'));
  // Bail if the PR doesn't touch any content files.
  if (newContent.length === 0 && modifiedContent.length === 0) return;
  // Store data about the new or modified content.
  if (newContent.length > 0) {
    newContent.forEach(file => {
      data.files[file.filename] = {
        status: 'added', // TODO(kaycebasques): Move to constants.json?
        url: url(number, file.filename),
        raw: file.raw_url,
        audits: {}
      };
    });
  }
  if (modifiedContent.length > 0) {
    modifiedContent.forEach(file => {
      data.files[file.filename] = {
        status: 'modified', // TODO(kaycebasques): Move to constants.json?
        url: url(number, file.filename),
        raw: file.raw_url,
        audits: {}
      };
    });
  }

  // Audit the files.
  for (const path in data.files) {
    const file = data.files[path];
    file.audits.markdown = await markdown.audit(file.raw, path);
    file.audits.psi = await psi.audit(file.url);
    file.audits.dom = await dom.audit(file.url);
  }

  // Get the comments on the pull request.
  const comments = await octokit.request({
    accept: 'application/vnd.github.v3+json',
    method: 'GET',
    url: `/repos/googlechrome/web.dev/issues/${number}/comments`
  });
  // Check for the auto-generated staging URLs comment.
  const stagingUrlsComment = comments.data.filter(comment => {
    return comment.body.includes(constants.comments.staging);
  });
  // Create the auto-generated staging URLs comment if it doesn't exist.
  if (stagingUrlsComment.length === 0) {
    await octokit.request({
      accept: 'application/vnd.github.v3+json',
      method: 'POST',
      url: `/repos/googlechrome/web.dev/issues/${data.number}/comments`,
      body: createStagingUrlsComment(data)
    });
  }
  // Otherwise just update it.
  if (stagingUrlsComment.length === 1) {
    await octokit.request({
      accept: 'application/vnd.github.v3+json',
      method: 'PATCH',
      url: `/repos/googlechrome/web.dev/issues/comments/${stagingUrlsComment[0].id}`,
      body: createStagingUrlsComment(data)
    });
  }

  // const reviewType = pr.data.user.login === 'kaycebasques' ? 'COMMENT' : 'REQUEST_CHANGES';
  // Cannot request changes on your own pull request
  // await octokit.request({
  //   accept: 'application/vnd.github.v3+json',
  //   method: 'POST',
  //   url: `/repos/googlechrome/web.dev/pulls/${number}/reviews`,
  //   body: createReviewComment(data),
  //   event: reviewType
  // });

  return createReviewComment(data);
  
  // https://www.googleapis.com/pagespeedonline/v5/runPagespeed?url=${url}
  

};

module.exports = {
  actions,
  audit
}